// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Subsystems/Arm.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "Commands/ArmManual.h"
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Arm::Arm() : frc::Subsystem("Arm") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    armMotor.reset(new WPI_TalonSRX(5));

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    armMotor->ConfigSelectedFeedbackSensor(FeedbackDevice::QuadEncoder, 0, kTimeoutMS);
    armMotor->SetSensorPhase(true); //NEEDS TO BE LOOKED INTO!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    armMotor->SetInverted(false); // !!!!!!!
    armMotor->SetStatusFramePeriod(StatusFrameEnhanced::Status_13_Base_PIDF0, 10, 10);
    armMotor->SetStatusFramePeriod(StatusFrameEnhanced::Status_10_MotionMagic, 10, kTimeoutMS);
    armMotor->ConfigNominalOutputForward(0, kTimeoutMS);
    armMotor->ConfigNominalOutputReverse(0, kTimeoutMS);
    armMotor->ConfigPeakOutputForward(1, kTimeoutMS);
    armMotor->ConfigPeakOutputReverse(-1, kTimeoutMS);
    armMotor->SelectProfileSlot(0, 0);
    armMotor->Config_kF(0, kF, kTimeoutMS);//these guys need to be set too!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    armMotor->Config_kP(0, kP, kTimeoutMS);    //!
    armMotor->Config_kI(0, 0, kTimeoutMS);    //!!
    armMotor->Config_kD(0, 0, kTimeoutMS);    //!!! 
    armMotor->ConfigMotionCruiseVelocity(350, kTimeoutMS); //!!!!
    armMotor->ConfigMotionAcceleration(350, kTimeoutMS); //!!!!!
    armMotor->SetSelectedSensorPosition(0, 0, kTimeoutMS); //look into the first value (initial sensor position)
    armMotor->ConfigForwardSoftLimitThreshold(5685, kTimeoutMS);
    //armMotor->ConfigReverseSoftLimitThreshold(-10000, kTimeoutMS);
    armMotor->ConfigClearPositionOnLimitR(true, kTimeoutMS);
    armMotor->ConfigForwardLimitSwitchSource(LimitSwitchSource::LimitSwitchSource_FeedbackConnector, LimitSwitchNormal_NormallyOpen, kTimeoutMS);
    armMotor->ConfigReverseLimitSwitchSource(LimitSwitchSource::LimitSwitchSource_FeedbackConnector, LimitSwitchNormal_NormallyOpen, kTimeoutMS);
    armMotor->ConfigMotionSCurveStrength(3, kTimeoutMS);
    armMotor->ConfigPeakCurrentLimit(20, kTimeoutMS);
    armMotor->EnableCurrentLimit(true);
}

void Arm::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new ArmManual());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Arm::Periodic() {
    // Put code here to be run every loop

}

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


// Put methods for controlling this subsystem
// here. Call these from Commands.

void Arm::userArm(std::shared_ptr<frc::Joystick>SystemsController)
{

    int ArmJoyNum = 5;

    double left_y = -0.5*SystemsController->GetRawAxis(ArmJoyNum);

    if(fabs(left_y) < 0.05)
    {
        left_y = 0;
    }

    armMotor->Set(ControlMode::PercentOutput, left_y);

}

void Arm::encoderReset()
{
    armMotor->SetSelectedSensorPosition(0, 0, kTimeoutMS);

    height_pos = 0.0;
}


void Arm::encoderDone()
{

    armMotor->Set(ControlMode::PercentOutput, 0.0);

}

double Arm::findDistance(double rotations)
{

    double currentPosition = armMotor->GetSelectedSensorPosition();
    double positionDifference = rotations - currentPosition;

    if(!(positionDifference <= 0.0))
    {

        return positionDifference;

    }

    else
    {

        return 0.0;

    }

}

void Arm::motionMagic(double rotations)
{

armMotor->Set(ControlMode::MotionMagic, rotations);

}

void Arm::armDown()
{

    armMotor->Set(ControlMode::PercentOutput, -0.4);

}

double Arm::getPosition(){
    double position = armMotor->GetSelectedSensorPosition();

    return position;

}

bool Arm::getLimitR(){
    return armMotor->GetSensorCollection().IsRevLimitSwitchClosed();
}

int Arm::distanceError(){

    return armMotor->GetClosedLoopError();

}

void Arm::armUp(){
    armMotor->Set(ControlMode::PercentOutput, 0.2);
}
